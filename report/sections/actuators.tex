Actuators are an important part of any control system because they are the ones responsible for bringing it to the desired state. They do this by applying forces on the system. In our case, the actuators are the motor and the propellers. Figure x displays the actuators' configuration. Ardupilot, which is the ''brain'' of our control system and has the controller implemented on it is connected to the speed controller, which is in charge of controlling the motor through a PWM signal. 

\begin{figure}[H]
  \centering
    \includegraphics[width=1\textwidth]{images/ablockd.png}
	\caption{Actuators Block Diagram}
	\label{ablockd}
\end{figure}

Each motor produces an angular velocity $\omega$, therefore the propeller spins at that defined angular velocity. In this chapter, we will be introducing more comprehensible models for both motor and propeller as well as some experiments regarding the PWM signal - motor speed relationship.

\section{Propeller model}
For this part of the report, we have decided not to take into account the aerodynamic forces that act on the propeller, therefore neglecting the air friction, the flapping of the biased and the ground effect. This enables us to create a simpler model, which is easy to understand and implement.

The thrust $F_{i}$ and the moment across the $M_{i}$ along the $u_{z}$ axis can be written as functions of angular velocities such as:

\begin{equation}
	F_{i}=K_{T}\omega_{i}^{2}
\end{equation}

\begin{equation}
	M_{i}=K_{M}\omega_{i}^{2}
\end{equation}

where the constant related to thrust $K_{T}$ and the constant related to the moment $K_{M}$ can be describes as:

\begin{equation}
	K_{T}=c_{T}\frac{\rho D^{4}}{4\Pi^{2}}
\end{equation}

\begin{equation}
	K_{M}=c_{P}\frac{\rho D^{5}}{8\Pi^{2}}
\end{equation}

with D= being the diameter of the propeller, $\rho$ being the air density, $ c_{T} $ and $ c_{P} $ being the thrust and power coefficient. We are considering these values to have small values (<0.2) based on what we have read from other projects.

Therefore:

\begin{equation}
	K_{T}\approx 1.45\times10^{-5}
\end{equation}

\begin{equation}
	K_{M} \approx 3.5\times10^{-7}
\end{equation}

%reference

We can write $K \approx K_{M}/K_{T}=4.1\times10^{-7}=0.024$. The forces and moments can now be expressed as:

\begin{equation}
\label{motor1} 
	F_{i}=K_{T}\omega_{i}^{2}
\end{equation}

\begin{equation}
\label{motor2} 
	M_{x}=(\omega_{2}^{2}-\omega_{4}^{2})K_{T}D=(F_{2}-F_{4})D
\end{equation}

\begin{equation}
\label{motor3} 
	M_{y}=(\omega_{1}^{2}-\omega_{3}^{2})K_{T}D=(F_{1}-F_{3})D
\end{equation}

\begin{equation}
\label{motor4} 
	M_{z}=(\omega_{1}^{2}+\omega_{3}^{2}-\omega_{2}^{2}-\omega_{4}^{2})K_{M}=(F_{1}+F_{3}-F_{2}-F_{4})K
\end{equation}

where D is expressed in centimetres.

\section{Motor model}
Providing a signal to the motor is done through Ardupilot, using PWM, which enables providing an analogue signal by digital means.  In order to create a PWM signal, we have used the \textit{write.Microseconds()} function from the\textit{Servo.h} library within the Arduino IDE environment. The role of the speed controllers is to turn the PWM signal into a three-phase signal to feed the BLDC motors.

Each motor receives a three-phase signal that is proportional with the angular velocity $\omega$. In general, the behaviour of a motor can be analysed by looking at the electrical and mechanical part of its structure. These parts are represented in Figure \ref{dc}. 

\begin{figure}[H]
  \centering
    \includegraphics[width=0.6\textwidth]{images/dc.png}
	\caption{Electrical and Mechanical part of the motor}\cite{MotorFig}
	\label{dc}
\end{figure}

%http://ctms.engin.umich.edu/CTMS/Content/MotorSpeed/Simulink/Modeling/figures/motor.png

A second order system can be obtained by writing the equations that describe the electrical and mechanical part as:

\begin{equation}
	V=RI+L\frac{dI}{dt}+K_{e}\dot{\theta}
\end{equation}

\begin{equation}
   K_{e}I = J \ddot{\theta}+b\dot{\theta}
\end{equation}

The transfer function can be taking the Laplace transform of each equation and manipulating it into:

\begin{equation}
\label{modelm} 
   \frac{\omega}{PWM}=\frac{K_{e}}{(Js+b)(Ls+R)+K_{e}^{2}}
\end{equation}

where $\omega$ is the angular velocity of the motor, PWM is the signal to the motor, $K_{e}$ is the electromotive constant, J is the rotor's moment of inertia, b is the damping ratio of the mechanical system, L is the inductance, R is the resistance and I is the measurement of the current.

Equation \ref{modelm} can be further simplified and written as a first order system, since it is difficult to measure all the motor parameters:\cite{Report1}

\begin{equation}
   \frac{\omega}{PWM}=\frac{k_{i}}{\tau s+1}
\end{equation}

%reference!! 

where $\tau$ is the time constant of the system and $k_{i}$ is the DC gain. 

\section{Motor and Ardupilot Identification}
This section will show the experiments that we have carried out in regards to the motor as well as Ardupilot frequency analysis.

\subsection{APM Frequency}
Due to lack of proper documentation, it was necessary to do measure the frequency of the signals sent out by the flight controller. To do so, an oscilloscope was connected to one of the output pins of the board. Then, using the servo library, a signal was sent out. The interval between signals was found to be 20$ms$, therefore, the frequency of the board is 50$Hz$, as seen in figure \ref{oscillo1}.
\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{images/oscillo1.jpg}
	\caption{Oscilloscope measuring APM's frequency}
	\label{oscillo1}
\end{figure}

The second experiment on the board was then made to determine how the flight controller handles the output signals during those 20$ms$. First two outputs of the APM were connected to the oscilloscope, both utilizing the Servo library to send signals of length of 2000$\mu s$. Results can be seen in figure \ref{oscillo2}.
\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{images/oscillo2.jpg}
	\caption{Readings of the two output signals}
	\label{oscillo2}
\end{figure}

Then, for further testing purposes, both outputs were given different values in two scenarios, as seen in figure \ref{oscillo3}.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{images/oscillo3.png}
	\caption{Left - signals running at 2000$\mu s$; Right - 700$\mu s$.}
	\label{oscillo3}
\end{figure}

From this, two conclusions can be made:
\begin{enumerate}
\item If the first signal is shorter than the second one, the second signal will still follow right after the first signal ends. In other words, the APM leaves no gaps between the outputs.
\item Since the board runs at the frequency of 50$Hz$ and has a period of 20$ms$, this leaves $\frac{20}{8} = 2.5ms$ maximum length for each output signal. The servo library is hard-capped at 2.4$ms$ and thus is well within the limits of the board.
\end{enumerate}

\subsection{Output Operating Range}

Since there is no direct translation between the output signal from the board and the speed of the motor and the ESC allows more current than the motor can recognise, it is necessary to find the operating range for the board output that has the most noticeable effect on the RPM of the motor. Through trial and error and by measuring the RPM using SHIMPO DT-205 digital tachometer. The lowest operating point was found to be 762$\mu s$, at which the motor finally begins to spin. The highest point was defined at 1200$\mu s$. Higher values were found to have very small effect on the RPM.
Therefore, despite the ESC recognising the values between 700 and 2000$\mu s$, the most noticeable effect will be between 762 and 1200$\mu s$ and will be primarily used in the project.

\subsection{Expected and Real Motor Performance}

The motors used in the prototype specify to be rated at $K_v$ of 980. $K_v$ is a constant describing the ration between RPM and the applied voltage and is expressed as $K_v = \frac{RPM}{V}$. Derived from this, voltage's effect on the RPM can be seen in figure \ref{KvPlot}.
\begin{figure}[H]
  \centering
    \includegraphics[width=0.8\textwidth]{images/KvPlot.png}
	\caption{Expected motor performance}
	\label{KvPlot}
\end{figure}
With a fully charged battery, the RPM is expected to be $980\times 11.1V = 10878 RPM$.

In order to confirm this, the actual RPM was measured using SHIMPO DT-205 digital tachometer. A piece of reflective paper was taped to one of the motors so that the tachometer would have something to lock onto, as seen in figure \ref{tachometer}.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{images/tachometer.jpg}
	\caption{Reflective paper on the motor}
	\label{tachometer}
\end{figure}

By sending the maximum signal from the board, the RPM was measured to be 10812, with a small possible error.
In conclusion, the motors' $K_v$ coefficient found in the datasheet is in fact correct.

\subsection{APM Output and Motor Speed Relationship}

In order to use the board's output signal as an input in a mathematical model, it is necessary to find an equation to translate it into an angular rate.
First, an equation has been found that describes the relationship between motor's RPM, ESC's output signal frequency and number of motor poles \cite{RPMEq}:

\begin{equation}
\label{voltage1}
	RPM = \frac{120\times f}{n}
\end{equation}
Here, $f$ is the frequency and $n$ is the number of poles (in the case of this project - 14).

Therefore, it is possible to measure the frequency at various output values, which can then be used to define an equation that uses the board's signal length as an input value and results in an RPM.

The frequency was measured using an (NAME) oscilloscope and by connecting the probe's ground clip to the ground of the battery and the probe tip to any one of the wires between motor and the ESC. Then, by providing different output signals from the flight controller, the frequency was measured on the oscilloscope screen. An on-board filter was used to filter out some noise, especially at lower output signals. The recorded frequency was later converted into RPM using equation \ref{voltage1}, for later comparison. The output signal lengths and the corresponding frequencies converted into RPM can be seen in table \ref{FreqTable}.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
$Output,\mu s$ 	& $RPM$ \\ \hline
762 			& 2825  \\ \hline
770				& 3189	\\ \hline
780				& 3689	\\ \hline
790				& 4211	\\ \hline
800 			& 4683  \\ \hline
810 			& 5161	\\ \hline
820 			& 5546  \\ \hline
830				& 5874 	\\ \hline
840				& 6223	\\ \hline
850 			& 6532	\\ \hline
860 			& 6795	\\ \hline
870 			& 7008	\\ \hline
880 			& 7301	\\ \hline
890 			& 7534	\\ \hline
900 			& 7730	\\ \hline
925 			& 8233	\\ \hline
950 			& 8552	\\ \hline
975 			& 8786	\\ \hline
1000 			& 9129	\\ \hline
1050 			& 9566	\\ \hline
1100 			& 9814	\\ \hline
1150 			& 10071	\\ \hline
1200			& 10260	\\ \hline
\end{tabular}
\caption{Frequency measured at ESC output, converted into RPM}
\label{FreqTable}
\end{table}

While measuring, it was observed that the frequency would never reach a steady-state and therefore, a sizeable error is possible between measurements. Because of that, RPM was manually measured using the tachometer at same output values, as seen in table \ref{RPMTable}.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
$Output,\mu s$ 	& $RPM$ \\ \hline
762 			& 2754	\\ \hline
770				& 3170	\\ \hline
780				& 3664	\\ \hline
790				& 4210	\\ \hline
800 			& 4715  \\ \hline
810 			& 5223	\\ \hline
820 			& 5617  \\ \hline
830				& 5965 	\\ \hline
840				& 6285	\\ \hline
850 			& 6578	\\ \hline
860 			& 6846	\\ \hline
870 			& 7100	\\ \hline
880 			& 7368	\\ \hline
890 			& 7555	\\ \hline
900 			& 7790	\\ \hline
925 			& 8265	\\ \hline
950 			& 8614	\\ \hline
975 			& 8910	\\ \hline
1000 			& 9160	\\ \hline
1050 			& 9576	\\ \hline
1100 			& 9860	\\ \hline
1150 			& 10089	\\ \hline
1200			& 10261	\\ \hline
\end{tabular}
\caption{RPM measured at different values}
\label{RPMTable}
\end{table}

While measuring with tachometer, the error appeared to be less significant.

The two tables \ref{RPMTable} and \ref{FreqTable} were then plotted to see the difference, which is seen in figure \ref{RPMvsFreq}.

\begin{figure}[H]
  \centering
    \includegraphics[width=1\textwidth]{images/rpm66.jpg}
	\caption{Plotted values of manually measured and frequency-based RPM}
	\label{RPMvsFreq}
\end{figure}

From the plotted graphs, it can be seen that the difference is very much noticeable, especially at certain points. Due to the fact that measurements with tachometer provided smaller errors than measurements with an oscilloscope, it was decided to use the values measured with the tachometer for later calculations.

In order to make use of these findings, the RPM values have to be converted into $rad/s$ for use as angular rate. The conversion equation is:
\begin{equation}
\label{RPMConvert}
	\omega = \frac{2\pi \times RPM}{60}
\end{equation}

The values measured with tachometer were then converted into $rad/s$ and plotted in Matlab. Then, by utilising the \textit{polyfit} function, a 2\textsuperscript{nd} order polynomial equation fitting the original graph was obtained. The equation seen in Figure \label{RadsTrendline} can then be used as an approximation for the conversion of the sent signal in $\mu s$ into angular rate.

\begin{figure}[H]
  \centering
    \includegraphics[width=1\textwidth]{images/mstorpm.jpg}
	\caption{Converted and plotted RPM values and the trendline}
	\label{RadsTrendline}
\end{figure}

\section{Electronic Speed Controllers}
ESCs have 5 input pins, 3 of which come from the flight controller. These 3 wires supply the signal for the ESC to translate into the angle of the shaft for the motor. Before ESCs can be used, they need to be properly calibrated. Programming additional settings is optional, but in most cases necessary too. Normally, the calibration for UAVs is done by setting the throttle to full on the radio controller before powering the ESCs. However, since the board translates the throttle signal into a PWM signal, it is possible to calibrate and run the motors directly from the flight controller by sending a PWM signal using software.

\subsection{Calibration and Programming}
The calibration is done by first sending the maximum length of signal the user wishes to use. The ESC emits sounds that are brand-specific and indicate whether the signal was successfully recognised or not. Once the maximum signal is accepted, the user the emits the minimum signal and waits for approval. Additional sound is then emitted, indicating that the calibration was successful.

Using Arduino's Servo library, a self-explanatory built-in function \textit{servo.writeMicroseconds(int value)} is used to send the signal. By default, the library has the minimum signal set to 544$\mu s$ and the maximum - to 2400$\mu s$. For this project, we shortened the range down to 700$\mu s$ and 2000$\mu s$ for both signals respectively. A commented code used to calibrate the ESC connected to the first pin of the board can be seen in listing \ref{code:calib}.

\lstinputlisting[language=C++, caption={Calibrating the ESC}, label={code:calib}]{Arduino/ESCCalib/ESCCalib.ino}

Programming additional settings of the ESC is done in a similar manner - by sending minimum and maximum signals after the ESC emits particular sounds, indicating wanted selections. The programmable features and selections are brand-specific and can be found in the datasheets. For the purposes of this project, the ESCs have been programmed to include two features - brake mode off and selection of li-ion battery.


